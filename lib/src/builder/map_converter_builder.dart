import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';
import 'package:dart_code/dart_code.dart' as code;
import 'package:logging/logging.dart';
import 'package:map_converter/src/builder/value_expression/value_expression_factory.dart';
import 'package:recase/recase.dart';

final valueExpressionFactories = ValueExpressionFactories();

class MapConverterBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
        '^lib/domain/{{}}.dart': ['lib/data/{{}}_map_converter.dart']
      };

  @override
  Future<FutureOr<void>> build(BuildStep buildStep) async {
    try {
      var idFactory = MapConverterLibraryAssetIdFactory(this);
      var libraryElement = await buildStep.inputLibrary;
      var library =
          MapConverterLibraryFactory().create(idFactory, libraryElement);
      if (library != null) {
        AssetId outputId = idFactory.createOutputId(buildStep.inputId);
        var dartCode = code.CodeFormatter().format(library);
        buildStep.writeAsString(outputId, dartCode);
      }
    } catch (e, stackTrace) {
      log.log(
          Level.SEVERE,
          'Error processing: ${buildStep.inputId.path}. Error: \n$e',
          stackTrace);
    }
  }
}

class MapConverterLibraryAssetIdFactory {
  final Builder builder;

  MapConverterLibraryAssetIdFactory(this.builder);

  /// [inputId] is the library file of the domain object(s).
  /// This will be converted to the library file that will
  /// contain the [MapConverter] for these domain object(s).
  AssetId createOutputId(AssetId inputId) {
    var assetIds = expectedOutputs(builder, inputId);
    var assetId = assetIds.first;
    return assetId;
  }

  String createOutputUriForType(InterfaceType domainObjectType) {
    var inputLibraryUri=domainObjectType.element2.librarySource.uri;
    var inputLibraryAssetId=AssetId.resolve(inputLibraryUri);
    var outputLibraryAssetId=createOutputId(inputLibraryAssetId);
    return outputLibraryAssetId.uri.toString();
  }
}

class MapConverterLibraryFactory {
  code.Library? create(MapConverterLibraryAssetIdFactory idFactory,
      LibraryElement libraryElement) {
    var domainClasses = DomainClassFactory().create(libraryElement);
    if (domainClasses.isEmpty) {
      return null;
    } else {
      return code.Library(
        docComments: _createDocComments(libraryElement),
        functions: _createFunctions(domainClasses, idFactory),
      );
    }
    // var result = '';
    // for (var domainClass in domainClasses) {
    //   result += '$domainClass.classElement\n';
    //
    //   for (FieldElement propertyElement in domainClass.propertyMap.keys) {
    //     var propertyType = propertyElement.type as InterfaceType;
    //     var valueExpressionFactory = domainClass.propertyMap[propertyElement];
    //     result +=
    //         '  $propertyType ${propertyElement.name} ${valueExpressionFactory.runtimeType}\n';
    //   }
    // }
    //
    // return result;
  }

  List<code.DartFunction> _createFunctions(
    List<DomainClass> domainClasses,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    var functions = <code.DartFunction>[];
    for (var domainClass in domainClasses) {
      functions
          .add(ObjectToMapFunctionFactory().create(domainClass, idFactory));
      //TODO functions.add(_createMapToObjectFunction(domainClass));
    }
    return functions;
  }

  List<code.DocComment> _createDocComments(LibraryElement libraryElement) => [
        code.DocComment.fromList([
          'Do not make changes to this file!',
          'This file is generated by: $MapConverterBuilder',
          'On: ${DateTime.now()}',
          'From: ${libraryElement.librarySource}',
          'Generate command: '
              'dart run build_runner build --delete-conflicting-outputs',
          'For more information see: TODO',

          ///TODO
        ])
      ];
}

class ObjectToMapFunctionFactory {
  code.DartFunction create(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    return code.DartFunction.withName(
      _createName(domainClass),
      _createBody(domainClass, idFactory),
      parameters: _createParameters(domainClass),
      returnType: _createReturnType(),
    );
  }

  String _createName(DomainClass domainClass) =>
      '${domainClass.classElement.displayName.camelCase}ToMap';

  code.CodeNode _createBody(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    Map<code.Expression, code.Expression> map = {};
    for (var propertyField in domainClass.propertyMap.keys) {
      var propertyNameExpression = code.Expression.ofString(propertyField.name);
      var expressionFactory = domainClass.propertyMap[propertyField]!;
      var nullable =
          propertyField.type.nullabilitySuffix == NullabilitySuffix.question;
      var propertyType = propertyField.type as InterfaceType;
      var instanceVariableName = domainClass.classElement.name.camelCase;
      var propertyValue = expressionFactory.createToMapValueCode(
          idFactory, instanceVariableName, propertyField.name, propertyType,
          nullable: nullable);
      map[propertyNameExpression] = propertyValue;
    }
    return code.Expression.ofMap(map);
  }

  code.Parameters _createParameters(DomainClass domainClass) =>
      code.Parameters([
        code.Parameter.required(
          domainClass.classElement.name.camelCase,
          type: code.Type(domainClass.classElement.name,
              libraryUri:
                  domainClass.classElement.librarySource.uri.toString()),
        ),
      ]);

  code.Type _createReturnType() => code.Type.ofMap(
      keyType: code.Type.ofString(), valueType: code.Type('dynamic'));
}

/// Contains information on a [DomainClass] to generate [MapConverter] codeclass DomainClass {
class DomainClass {
  final ClassElement classElement;
  final Map<FieldElement, ValueExpressionFactory> propertyMap;

  DomainClass(
    this.classElement,
    this.propertyMap,
  );
}

class DomainClassFactory {
  List<DomainClass> create(LibraryElement libraryElement) {
    var domainClasses = <DomainClass>[];
    var topElements = libraryElement.topLevelElements;
    for (var topElement in topElements) {
      if (_isDomainClass(topElement)) {
        var classElement = topElement as ClassElement;
        var propertyMap = _createPropertyMap(classElement);
        if (propertyMap.isNotEmpty) {
          var domainClass = DomainClass(classElement, propertyMap);
          domainClasses.add(domainClass);
        }
      }
    }
    return domainClasses;
  }

  bool _isDomainClass(Element element) {
    return element is ClassElement &&
        element.isPublic &&
        !element.isAbstract &&
        element is! EnumElement &&
        element.thisType.allSupertypes
            .none((e) => _isListSetMapIteratorType(e.element2));
  }

  bool isDomainClassWithSupportedPropertyTypes(Element element) {
    return _isDomainClass(element) &&
        _createPropertyMap(element as ClassElement).isNotEmpty;
  }

  _isListSetMapIteratorType(InterfaceElement element) {
    String string = element.toString();
    // print("-- $string");
    return element.library.name == 'dart.core' &&
        (string.contains('class List<') ||
            string.contains('class Set<') ||
            string.contains('class Map<') ||
            string.contains('class Iterator<'));
  }

  /// Gets all fields that represent properties from the [InterfaceElement]
  /// including those from super classes, mixins and interfaces
  List<FieldElement> _findAllProperties(InterfaceElement interfaceElement) {
    Map<String, FieldElement> fields = {};
    for (var fieldElement in interfaceElement.fields) {
      if (_isPropertyField(fieldElement)) {
        fields[fieldElement.name] = fieldElement;
      }
    }
    for (var superType in interfaceElement.allSupertypes) {
      var superTypeFields = _findAllProperties(superType.element2);
      for (var superTypeField in superTypeFields) {
        fields[superTypeField.name] = superTypeField;
      }
    }
    return fields.values.toList();
  }

  /// creates a [MAP] with [FieldElement] and [ValueExpressionFactory] for
  /// any property in a [ClassElement]
  /// if there is a matching [ValueExpressionFactory].
  Map<FieldElement, ValueExpressionFactory> _createPropertyMap(
      InterfaceElement classElement) {
    var propertyMap = <FieldElement, ValueExpressionFactory>{};
    var properties = _findAllProperties(classElement);
    for (var property in properties) {
      var propertyType = property.type as InterfaceType;

      var valueExpressionFactory =
          valueExpressionFactories.findFor(classElement, propertyType);
      if (valueExpressionFactory == null) {
        log.log(
            Level.WARNING,
            'Could not find a $ValueExpressionFactory '
            'for type: $propertyType '
            'used in property: ${classElement.name}.${property.name}');
      } else {
        propertyMap[property] = valueExpressionFactory;
      }
    }
    return propertyMap;
  }

  bool _isPropertyField(FieldElement fieldElement) =>
      !fieldElement.isAbstract &&
      !fieldElement.isStatic &&
      !fieldElement.isConst &&
      (fieldElement.setter != null || _isSetInConstructor(fieldElement)) &&
      fieldElement.type is InterfaceType;

  bool _isSetInConstructor(FieldElement fieldElement) => false;
}
