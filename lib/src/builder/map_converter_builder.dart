import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';
import 'package:dart_code/dart_code.dart' as code;
import 'package:logging/logging.dart';
import 'package:map_converter/src/builder/value_expression/value_expression_factory.dart';
import 'package:recase/recase.dart';

final valueExpressionFactories = ValueExpressionFactories();

class MapConverterBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
        '^lib/domain/{{}}.dart': ['lib/data/{{}}_map_converter.dart']
      };

  @override
  Future<FutureOr<void>> build(BuildStep buildStep) async {
    try {
      var idFactory = MapConverterLibraryAssetIdFactory(this);
      var libraryElement = await buildStep.inputLibrary;
      var library =
          MapConverterLibraryFactory().create(idFactory, libraryElement);
      if (library != null) {
        AssetId outputId = idFactory.createOutputId(buildStep.inputId);
        var dartCode = code.CodeFormatter().format(library);
        buildStep.writeAsString(outputId, dartCode);
      }
    } catch (e, stackTrace) {
      log.log(
          Level.SEVERE,
          'Error processing: ${buildStep.inputId.path}. Error: \n$e',
          stackTrace);
    }
  }
}

class MapConverterLibraryAssetIdFactory {
  final Builder builder;

  MapConverterLibraryAssetIdFactory(this.builder);

  /// [inputId] is the library file of the domain object(s).
  /// This will be converted to the library file that will
  /// contain the [MapConverter] for these domain object(s).
  AssetId createOutputId(AssetId inputId) {
    var assetIds = expectedOutputs(builder, inputId);
    var assetId = assetIds.first;
    return assetId;
  }

  String createOutputUriForType(InterfaceType domainObjectType) {
    var inputLibraryUri = domainObjectType.element2.librarySource.uri;
    var inputLibraryAssetId = AssetId.resolve(inputLibraryUri);
    var outputLibraryAssetId = createOutputId(inputLibraryAssetId);
    return outputLibraryAssetId.uri.toString();
  }
}

class MapConverterLibraryFactory {
  code.Library? create(MapConverterLibraryAssetIdFactory idFactory,
      LibraryElement libraryElement) {
    var domainClasses = DomainClassFactory().create(libraryElement);
    if (domainClasses.isEmpty) {
      return null;
    } else {
      return code.Library(
        docComments: _createDocComments(libraryElement),
        functions: _createFunctions(domainClasses, idFactory),
      );
    }
    // var result = '';
    // for (var domainClass in domainClasses) {
    //   result += '$domainClass.classElement\n';
    //
    //   for (FieldElement propertyElement in domainClass.propertyMap.keys) {
    //     var propertyType = propertyElement.type as InterfaceType;
    //     var valueExpressionFactory = domainClass.propertyMap[propertyElement];
    //     result +=
    //         '  $propertyType ${propertyElement.name} ${valueExpressionFactory.runtimeType}\n';
    //   }
    // }
    //
    // return result;
  }

  List<code.DartFunction> _createFunctions(
    List<DomainClass> domainClasses,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    var functions = <code.DartFunction>[];
    for (var domainClass in domainClasses) {
      functions
          .add(ObjectToMapFunctionFactory().create(domainClass, idFactory));
      functions
          .add(MapToObjectFunctionFactory().create(domainClass, idFactory));
    }
    return functions;
  }

  List<code.DocComment> _createDocComments(LibraryElement libraryElement) => [
        code.DocComment.fromList([
          'Do not make changes to this file!',
          'This file is generated by: $MapConverterBuilder',
          'On: ${DateTime.now()}',
          'From: ${libraryElement.librarySource}',
          'Generate command: '
              'dart run build_runner build --delete-conflicting-outputs',
          'For more information see: TODO',

          ///TODO
        ])
      ];
}

class ObjectToMapFunctionFactory {
  code.DartFunction create(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    return code.DartFunction.withName(
      _createName(domainClass),
      _createBody(domainClass, idFactory),
      parameters: _createParameters(domainClass),
      returnType: _createReturnType(),
    );
  }

  String _createName(DomainClass domainClass) =>
      '${domainClass.element.displayName.camelCase}ToMap';

  code.CodeNode _createBody(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    Map<code.Expression, code.Expression> map = {};
    for (var property in domainClass.properties) {
      var propertyNameExpression =
          code.Expression.ofString(property.element.name);
      var expressionFactory = property.valueExpressionFactory;
      var nullable =
          property.element.type.nullabilitySuffix == NullabilitySuffix.question;
      var propertyType = property.element.type as InterfaceType;
      var instanceVariableName = domainClass.element.name.camelCase;
      var propertyValue = expressionFactory.createToMapValueCode(
        idFactory,
        instanceVariableName,
        property.element.name,
        propertyType,
        nullable: nullable,
      );
      map[propertyNameExpression] = propertyValue;
    }
    return code.Expression.ofMap(map);
  }

  code.Parameters _createParameters(DomainClass domainClass) =>
      code.Parameters([
        code.Parameter.required(
          domainClass.element.name.camelCase,
          type: code.Type(domainClass.element.name,
              libraryUri: domainClass.element.librarySource.uri.toString()),
        ),
      ]);

  code.Type _createReturnType() => code.Type.ofMap(
      keyType: code.Type.ofString(), valueType: code.Type('dynamic'));
}

class MapToObjectFunctionFactory {
  code.DartFunction create(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    return code.DartFunction.withName(
      _createName(domainClass),
      _createBody(domainClass, idFactory),
      parameters: _createParameters(domainClass),
      returnType: _createReturnType(domainClass),
    );
  }

  String _createName(DomainClass domainClass) =>
      'mapTo${domainClass.element.displayName}';

  code.CodeNode _createBody(
    DomainClass domainClass,
    MapConverterLibraryAssetIdFactory idFactory,
  ) {
    var constructorCall =
        code.Expression.callConstructor(_createReturnType(domainClass));
    for (var property in domainClass.properties) {
      var propertyName = property.element.name;
      var expressionFactory = property.valueExpressionFactory;
      var nullable =
          property.element.type.nullabilitySuffix == NullabilitySuffix.question;
      var propertyType = property.element.type as InterfaceType;
      String mapVariableName = domainMapVariableName(domainClass);
      var propertyValue = expressionFactory.createToObjectPropertyValueCode(
        idFactory,
        mapVariableName,
        propertyName,
        propertyType,
        nullable: nullable,
      );
      constructorCall = constructorCall.setProperty(propertyName, propertyValue,
          cascade: true);
    }
    return constructorCall;
  }

  code.Parameters _createParameters(DomainClass domainClass) =>
      code.Parameters([
        code.Parameter.required(
          domainMapVariableName(domainClass),
          type: code.Type.ofMap(
              keyType: code.Type.ofString(), valueType: code.Type('dynamic')),
        ),
      ]);

  code.Type _createReturnType(DomainClass domainClass) =>
      code.Type(domainClass.element.name,
          libraryUri: domainClass.element.librarySource.uri.toString());

  String domainMapVariableName(DomainClass domainClass) =>
      '${domainClass.element.name.camelCase}Map';
}

/// Contains information on a [DomainClass] to generate [MapConverter]s
class DomainClass {
  final ClassElement element;
  final Constructor bestConstructor;
  final List<Property> properties;

  DomainClass(
    this.element,
    this.bestConstructor,
    this.properties,
  );
}

class Constructor {
  final String? name;
  final List<Property> requiredPositionalParameters;
  final List<Property> namedParameters;
  final List<Property> optionalParameters;

  Constructor(
    this.name,
    this.requiredPositionalParameters,
    this.namedParameters,
    this.optionalParameters,
  );
}

class Property {
  final FieldElement element;
  final ValueExpressionFactory valueExpressionFactory;

  Property(
    this.element,
    this.valueExpressionFactory,
  );
}

class DomainClassFactory {
  List<DomainClass> create(LibraryElement libraryElement) {
    var domainClasses = <DomainClass>[];
    var topElements = libraryElement.topLevelElements;
    for (var topElement in topElements) {
      if (_isDomainClass(topElement)) {
        var classElement = topElement as ClassElement;
        var properties = _createProperties(classElement);
        if (properties.isNotEmpty) {
          var bestConstructor = _findBestConstructor(classElement);
          var domainClass =
              DomainClass(classElement, bestConstructor, properties);
          domainClasses.add(domainClass);
        }
      }
    }
    return domainClasses;
  }

  bool _isDomainClass(Element element) {
    return element is ClassElement &&
        element.isPublic &&
        !element.isAbstract &&
        element is! EnumElement &&
        element.thisType.allSupertypes
            .none((e) => _isListSetMapIteratorType(e.element2));
  }

  bool isDomainClassWithSupportedPropertyTypes(Element element) {
    return _isDomainClass(element) &&
        _createProperties(element as ClassElement).isNotEmpty;
  }

  _isListSetMapIteratorType(InterfaceElement element) {
    String string = element.toString();
    // print("-- $string");
    return element.library.name == 'dart.core' &&
        (string.contains('class List<') ||
            string.contains('class Set<') ||
            string.contains('class Map<') ||
            string.contains('class Iterator<'));
  }

  /// Gets all fields that represent properties from the [InterfaceElement]
  /// including those from super classes, mixins and interfaces
  List<FieldElement> _findAllFields(InterfaceElement interfaceElement) {
    Map<String, FieldElement> fields = {};
    for (var fieldElement in interfaceElement.fields) {
      if (_isPropertyField(fieldElement)) {
        fields[fieldElement.name] = fieldElement;
      }
    }
    for (var superType in interfaceElement.allSupertypes) {
      var superTypeFields = _findAllFields(superType.element2);
      for (var superTypeField in superTypeFields) {
        fields[superTypeField.name] = superTypeField;
      }
    }
    return fields.values.toList();
  }

  /// creates a [MAP] with [FieldElement] and [ValueExpressionFactory] for
  /// any property in a [ClassElement]
  /// if there is a matching [ValueExpressionFactory].
  List<Property> _createProperties(InterfaceElement classElement) {
    var properties = <Property>[];
    var fields = _findAllFields(classElement);
    for (var field in fields) {
      var propertyType = field.type as InterfaceType;

      var valueExpressionFactory =
          valueExpressionFactories.findFor(classElement, propertyType);
      if (valueExpressionFactory == null) {
        log.log(
            Level.WARNING,
            'Could not find a $ValueExpressionFactory '
            'for type: $propertyType '
            'used in property: ${classElement.name}.${field.name}');
      } else {
        var property = Property(field, valueExpressionFactory);
        properties.add(property);
      }
    }
    return properties;
  }

  bool _isPropertyField(FieldElement fieldElement) =>
      !fieldElement.isAbstract &&
      !fieldElement.isStatic &&
      !fieldElement.isConst &&
      (fieldElement.setter != null || _isSetInConstructor(fieldElement)) &&
      fieldElement.type is InterfaceType;

  bool _isSetInConstructor(FieldElement fieldElement) => false;

  Constructor _findBestConstructor(ClassElement classElement) =>
      Constructor(null, [], [], []); //TODO
}
